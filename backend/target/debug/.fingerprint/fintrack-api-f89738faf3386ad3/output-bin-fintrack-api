{"$message_type":"diagnostic","message":"unused import: `auth::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/middleware/mod.rs","byte_start":23,"byte_end":30,"line_start":3,"line_end":3,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use auth::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/middleware/mod.rs","byte_start":15,"byte_end":32,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use auth::*;","highlight_start":1,"highlight_end":17},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `auth::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/middleware/mod.rs:3:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use auth::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `user::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/models/mod.rs","byte_start":78,"byte_end":85,"line_start":6,"line_end":6,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"pub use user::*;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/models/mod.rs","byte_start":70,"byte_end":87,"line_start":6,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use user::*;","highlight_start":1,"highlight_end":17},{"text":"pub use wallet::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `user::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:6:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use user::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `wallet::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/models/mod.rs","byte_start":95,"byte_end":104,"line_start":7,"line_end":7,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"pub use wallet::*;","highlight_start":9,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/models/mod.rs","byte_start":87,"byte_end":106,"line_start":7,"line_end":8,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use wallet::*;","highlight_start":1,"highlight_end":19},{"text":"pub use transaction::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `wallet::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:7:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use wallet::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `transaction::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/models/mod.rs","byte_start":114,"byte_end":128,"line_start":8,"line_end":8,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"pub use transaction::*;","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/models/mod.rs","byte_start":106,"byte_end":130,"line_start":8,"line_end":9,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use transaction::*;","highlight_start":1,"highlight_end":24},{"text":"pub use category::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `transaction::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:8:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use transaction::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `category::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/models/mod.rs","byte_start":138,"byte_end":149,"line_start":9,"line_end":9,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"pub use category::*;","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/models/mod.rs","byte_start":130,"byte_end":151,"line_start":9,"line_end":10,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use category::*;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `category::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:9:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use category::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `jwt::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/utils/mod.rs","byte_start":40,"byte_end":46,"line_start":4,"line_end":4,"column_start":9,"column_end":15,"is_primary":true,"text":[{"text":"pub use jwt::*;","highlight_start":9,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/utils/mod.rs","byte_start":32,"byte_end":48,"line_start":4,"line_end":5,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use jwt::*;","highlight_start":1,"highlight_end":16},{"text":"pub use password::*;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `jwt::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/utils/mod.rs:4:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use jwt::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `password::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/utils/mod.rs","byte_start":56,"byte_end":67,"line_start":5,"line_end":5,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"pub use password::*;","highlight_start":9,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/utils/mod.rs","byte_start":48,"byte_end":69,"line_start":5,"line_end":6,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub use password::*;","highlight_start":1,"highlight_end":21},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `password::*`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/utils/mod.rs:5:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use password::*;\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1009,"byte_end":1015,"line_start":33,"line_end":33,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"    sqlx::query_as::<_, Wallet>(","highlight_start":25,"highlight_end":31}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:33:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1009,"byte_end":1015,"line_start":33,"line_end":33,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"    sqlx::query_as::<_, Wallet>(","highlight_start":25,"highlight_end":31}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:33:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":989,"byte_end":1214,"line_start":33,"line_end":38,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    sqlx::query_as::<_, Wallet>(","highlight_start":5,"highlight_end":33},{"text":"        r#\"SELECT id, user_id, name, wallet_type, balance, icon, color, created_at, updated_at ","highlight_start":1,"highlight_end":96},{"text":"           FROM wallets WHERE user_id = $1 ORDER BY created_at DESC\"#","highlight_start":1,"highlight_end":70},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_all(pool)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":1214,"byte_end":1223,"line_start":38,"line_end":38,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(pool)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/wallet.rs","byte_start":199,"byte_end":216,"line_start":8,"line_end":8,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Wallet {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `Wallet: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:38:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m     sqlx::query_as::<_, Wallet>(\n \u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"SELECT id, user_id, name, wallet_type, balance, icon, color, cr\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m            FROM wallets WHERE user_id = $1 ORDER BY created_at DESC\"#\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(pool)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/wallet.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Wallet: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1379,"byte_end":1385,"line_start":43,"line_end":43,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"    sqlx::query_as::<_, Wallet>(","highlight_start":25,"highlight_end":31}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:43:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1379,"byte_end":1385,"line_start":43,"line_end":43,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"    sqlx::query_as::<_, Wallet>(","highlight_start":25,"highlight_end":31}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:43:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1359,"byte_end":1585,"line_start":43,"line_end":49,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    sqlx::query_as::<_, Wallet>(","highlight_start":5,"highlight_end":33},{"text":"        r#\"SELECT id, user_id, name, wallet_type, balance, icon, color, created_at, updated_at ","highlight_start":1,"highlight_end":96},{"text":"           FROM wallets WHERE id = $1 AND user_id = $2\"#","highlight_start":1,"highlight_end":57},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(pool)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":1585,"byte_end":1599,"line_start":49,"line_end":49,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(pool)","highlight_start":6,"highlight_end":20}],"label":"method cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/wallet.rs","byte_start":199,"byte_end":216,"line_start":8,"line_end":8,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Wallet {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `Wallet: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:49:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m     sqlx::query_as::<_, Wallet>(\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"SELECT id, user_id, name, wallet_type, balance, icon, color, cr\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m            FROM wallets WHERE id = $1 AND user_id = $2\"#\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(user_id)\n \u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(pool)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/wallet.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Wallet: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1820,"byte_end":1831,"line_start":60,"line_end":60,"column_start":25,"column_end":36,"is_primary":true,"text":[{"text":"    sqlx::query_as::<_, Transaction>(","highlight_start":25,"highlight_end":36}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:60:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1820,"byte_end":1831,"line_start":60,"line_end":60,"column_start":25,"column_end":36,"is_primary":true,"text":[{"text":"    sqlx::query_as::<_, Transaction>(","highlight_start":25,"highlight_end":36}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:60:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/db.rs","byte_start":1800,"byte_end":2110,"line_start":60,"line_end":67,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    sqlx::query_as::<_, Transaction>(","highlight_start":5,"highlight_end":38},{"text":"        r#\"SELECT id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":123},{"text":"           FROM transactions WHERE user_id = $1 ORDER BY date DESC LIMIT $2 OFFSET $3\"#","highlight_start":1,"highlight_end":88},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(limit)","highlight_start":1,"highlight_end":17},{"text":"    .bind(offset)","highlight_start":1,"highlight_end":18},{"text":"    .fetch_all(pool)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/db.rs","byte_start":2110,"byte_end":2119,"line_start":67,"line_end":67,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(pool)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/transaction.rs","byte_start":210,"byte_end":232,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"pub struct Transaction {","highlight_start":1,"highlight_end":23}],"label":"doesn't satisfy `_: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-3223879690857463562.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/db.rs:67:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m     sqlx::query_as::<_, Transaction>(\n \u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"SELECT id, user_id, wallet_id, category_id, transaction_type, a\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m            FROM transactions WHERE user_id = $1 ORDER BY date DESC LIMIT $\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(offset)\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(pool)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/transaction.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-3223879690857463562.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/auth.rs","byte_start":5084,"byte_end":5115,"line_start":174,"line_end":174,"column_start":11,"column_end":42,"is_primary":true,"text":[{"text":"    .bind(bigdecimal::BigDecimal::from(0))","highlight_start":11,"highlight_end":42}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/auth.rs","byte_start":5079,"byte_end":5083,"line_start":174,"line_end":174,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(bigdecimal::BigDecimal::from(0))","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs","byte_start":2937,"byte_end":2951,"line_start":81,"line_end":81,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/auth.rs:174:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(bigdecimal::BigDecimal::from(0))\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `&'a str` implements `Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n              `&T` implements `Encode<'q, DB>`\n              `&[T]` implements `Encode<'q, Postgres>`\n              `&[u8]` implements `Encode<'_, Postgres>`\n              `&str` implements `Encode<'_, Postgres>`\n              `Box<[u8]>` implements `Encode<'_, Postgres>`\n              `Box<str>` implements `Encode<'_, Postgres>`\n            and 42 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs:81:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/auth.rs","byte_start":5084,"byte_end":5115,"line_start":174,"line_end":174,"column_start":11,"column_end":42,"is_primary":true,"text":[{"text":"    .bind(bigdecimal::BigDecimal::from(0))","highlight_start":11,"highlight_end":42}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/auth.rs","byte_start":5079,"byte_end":5083,"line_start":174,"line_end":174,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(bigdecimal::BigDecimal::from(0))","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs","byte_start":2954,"byte_end":2962,"line_start":81,"line_end":81,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/auth.rs","byte_start":5084,"byte_end":5084,"line_start":174,"line_end":174,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(bigdecimal::BigDecimal::from(0))","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/auth.rs","byte_start":5115,"byte_end":5115,"line_start":174,"line_end":174,"column_start":42,"column_end":42,"is_primary":true,"text":[{"text":"    .bind(bigdecimal::BigDecimal::from(0))","highlight_start":42,"highlight_end":42}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/auth.rs:174:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(bigdecimal::BigDecimal::from(0))\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs:81:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m174\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0mbigdecimal::BigDecimal::from(0)\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m                               \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1370,"byte_end":1379,"line_start":51,"line_end":51,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:51:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1370,"byte_end":1379,"line_start":51,"line_end":51,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:51:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1246,"byte_end":1345,"line_start":47,"line_end":49,"column_start":40,"column_end":6,"is_primary":true,"text":[{"text":"    let total_balance: (BigDecimal,) = sqlx::query_as(","highlight_start":40,"highlight_end":55},{"text":"        r#\"SELECT COALESCE(SUM(balance), 0) FROM wallets WHERE user_id = $1\"#","highlight_start":1,"highlight_end":78},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:47:40\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let total_balance: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________________^\u001b[0m\n \u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(balance), 0) FROM wallets WHERE user_id = $1\"#\n \u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1246,"byte_end":1345,"line_start":47,"line_end":49,"column_start":40,"column_end":6,"is_primary":true,"text":[{"text":"    let total_balance: (BigDecimal,) = sqlx::query_as(","highlight_start":40,"highlight_end":55},{"text":"        r#\"SELECT COALESCE(SUM(balance), 0) FROM wallets WHERE user_id = $1\"#","highlight_start":1,"highlight_end":78},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:47:40\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let total_balance: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________________^\u001b[0m\n \u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(balance), 0) FROM wallets WHERE user_id = $1\"#\n \u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1627,"byte_end":1636,"line_start":59,"line_end":59,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:59:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1627,"byte_end":1636,"line_start":59,"line_end":59,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:59:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1467,"byte_end":1602,"line_start":55,"line_end":57,"column_start":39,"column_end":6,"is_primary":true,"text":[{"text":"    let total_income: (BigDecimal,) = sqlx::query_as(","highlight_start":39,"highlight_end":54},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'income'\"#","highlight_start":1,"highlight_end":114},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:55:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let total_income: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________________________________^\u001b[0m\n \u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1467,"byte_end":1602,"line_start":55,"line_end":57,"column_start":39,"column_end":6,"is_primary":true,"text":[{"text":"    let total_income: (BigDecimal,) = sqlx::query_as(","highlight_start":39,"highlight_end":54},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'income'\"#","highlight_start":1,"highlight_end":114},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:55:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let total_income: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________________________________^\u001b[0m\n \u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1887,"byte_end":1896,"line_start":67,"line_end":67,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:67:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1887,"byte_end":1896,"line_start":67,"line_end":67,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:67:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1726,"byte_end":1862,"line_start":63,"line_end":65,"column_start":40,"column_end":6,"is_primary":true,"text":[{"text":"    let total_expense: (BigDecimal,) = sqlx::query_as(","highlight_start":40,"highlight_end":55},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'expense'\"#","highlight_start":1,"highlight_end":115},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:63:40\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let total_expense: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________________^\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":1726,"byte_end":1862,"line_start":63,"line_end":65,"column_start":40,"column_end":6,"is_primary":true,"text":[{"text":"    let total_expense: (BigDecimal,) = sqlx::query_as(","highlight_start":40,"highlight_end":55},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'expense'\"#","highlight_start":1,"highlight_end":115},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:63:40\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let total_expense: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________________________________^\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2312,"byte_end":2321,"line_start":79,"line_end":79,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:79:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2312,"byte_end":2321,"line_start":79,"line_end":79,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:79:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2116,"byte_end":2266,"line_start":74,"line_end":76,"column_start":44,"column_end":6,"is_primary":true,"text":[{"text":"    let this_month_income: (BigDecimal,) = sqlx::query_as(","highlight_start":44,"highlight_end":59},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'income' AND date >= $2\"#","highlight_start":1,"highlight_end":129},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:74:44\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let this_month_income: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________________________________^\u001b[0m\n \u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2116,"byte_end":2266,"line_start":74,"line_end":76,"column_start":44,"column_end":6,"is_primary":true,"text":[{"text":"    let this_month_income: (BigDecimal,) = sqlx::query_as(","highlight_start":44,"highlight_end":59},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'income' AND date >= $2\"#","highlight_start":1,"highlight_end":129},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:74:44\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let this_month_income: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________________________________^\u001b[0m\n \u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2588,"byte_end":2597,"line_start":87,"line_end":87,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:87:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2588,"byte_end":2597,"line_start":87,"line_end":87,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":5425,"byte_end":5434,"line_start":160,"line_end":160,"column_start":18,"column_end":27,"is_primary":false,"text":[{"text":"    pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Error>","highlight_start":18,"highlight_end":27}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":2527,"byte_end":2555,"line_start":86,"line_end":86,"column_start":23,"column_end":51,"is_primary":true,"text":[{"text":"    O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,","highlight_start":23,"highlight_end":51}],"label":"required by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:87:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m87\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, A>::fetch_one`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:86:23\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: Send + Unpin + for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, A>::fetch_one`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub async fn fetch_one<'e, 'c: 'e, E>(self, executor: E) -> Result<O, Er\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2391,"byte_end":2542,"line_start":82,"line_end":84,"column_start":45,"column_end":6,"is_primary":true,"text":[{"text":"    let this_month_expense: (BigDecimal,) = sqlx::query_as(","highlight_start":45,"highlight_end":60},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'expense' AND date >= $2\"#","highlight_start":1,"highlight_end":130},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:82:45\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let this_month_expense: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _____________________________________________^\u001b[0m\n \u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `sqlx::Decode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":2391,"byte_end":2542,"line_start":82,"line_end":84,"column_start":45,"column_end":6,"is_primary":true,"text":[{"text":"    let this_month_expense: (BigDecimal,) = sqlx::query_as(","highlight_start":45,"highlight_end":60},{"text":"        r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id = $1 AND transaction_type = 'expense' AND date >= $2\"#","highlight_start":1,"highlight_end":130},{"text":"    )","highlight_start":1,"highlight_end":6}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:82:45\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m82\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let this_month_expense: (BigDecimal,) = sqlx::query_as(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _____________________________________________^\u001b[0m\n \u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT COALESCE(SUM(amount), 0) FROM transactions WHERE user_id\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_____^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `(bigdecimal::BigDecimal,)` to implement `for<'r> FromRow<'r, PgRow>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":1236,"byte_end":1247,"line_start":44,"line_end":44,"column_start":44,"column_end":55,"is_primary":true,"text":[{"text":"    let transactions = sqlx::query_as::<_, Transaction>(","highlight_start":44,"highlight_end":55}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:44:44\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transactions = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":1236,"byte_end":1247,"line_start":44,"line_end":44,"column_start":44,"column_end":55,"is_primary":true,"text":[{"text":"    let transactions = sqlx::query_as::<_, Transaction>(","highlight_start":44,"highlight_end":55}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:44:44\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transactions = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":1216,"byte_end":1994,"line_start":44,"line_end":66,"column_start":24,"column_end":6,"is_primary":false,"text":[{"text":"    let transactions = sqlx::query_as::<_, Transaction>(","highlight_start":24,"highlight_end":57},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":120},{"text":"        FROM transactions ","highlight_start":1,"highlight_end":27},{"text":"        WHERE user_id = $1","highlight_start":1,"highlight_end":27},{"text":"            AND ($2::uuid IS NULL OR wallet_id = $2)","highlight_start":1,"highlight_end":53},{"text":"            AND ($3::uuid IS NULL OR category_id = $3)","highlight_start":1,"highlight_end":55},{"text":"            AND ($4::text IS NULL OR transaction_type = $4)","highlight_start":1,"highlight_end":60},{"text":"            AND ($5::date IS NULL OR date >= $5)","highlight_start":1,"highlight_end":49},{"text":"            AND ($6::date IS NULL OR date <= $6)","highlight_start":1,"highlight_end":49},{"text":"        ORDER BY date DESC, created_at DESC","highlight_start":1,"highlight_end":44},{"text":"        LIMIT $7 OFFSET $8","highlight_start":1,"highlight_end":27},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(query.wallet_id)","highlight_start":1,"highlight_end":27},{"text":"    .bind(query.category_id)","highlight_start":1,"highlight_end":29},{"text":"    .bind(&query.transaction_type)","highlight_start":1,"highlight_end":35},{"text":"    .bind(query.start_date)","highlight_start":1,"highlight_end":28},{"text":"    .bind(query.end_date)","highlight_start":1,"highlight_end":26},{"text":"    .bind(limit)","highlight_start":1,"highlight_end":17},{"text":"    .bind(offset)","highlight_start":1,"highlight_end":18},{"text":"    .fetch_all(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":1994,"byte_end":2003,"line_start":66,"line_end":66,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/transaction.rs","byte_start":210,"byte_end":232,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"pub struct Transaction {","highlight_start":1,"highlight_end":23}],"label":"doesn't satisfy `_: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-17879311897055733178.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:66:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transactions = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________________-\u001b[0m\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         SELECT id, user_id, wallet_id, category_id, transaction_type, amou\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         FROM transactions \n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(offset)\n \u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/transaction.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-17879311897055733178.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":2074,"byte_end":2086,"line_start":69,"line_end":69,"column_start":46,"column_end":58,"is_primary":false,"text":[{"text":"    let response: Vec<TransactionResponse> = transactions.into_iter().map(TransactionResponse::from).collect();","highlight_start":46,"highlight_end":58}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":1201,"byte_end":1213,"line_start":44,"line_end":44,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"    let transactions = sqlx::query_as::<_, Transaction>(","highlight_start":9,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `transactions` an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":1213,"byte_end":1213,"line_start":44,"line_end":44,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"    let transactions = sqlx::query_as::<_, Transaction>(","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:44:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transactions = sqlx::query_as::<_, Transaction>(\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let response: Vec<TransactionResponse> = transactions.into_iter().map(Tra\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `transactions` an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let transactions\u001b[92m: /* Type */\u001b[0m = sqlx::query_as::<_, Transaction>(\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":3180,"byte_end":3191,"line_start":107,"line_end":107,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:107:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m107\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":3180,"byte_end":3191,"line_start":107,"line_end":107,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:107:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m107\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":3654,"byte_end":3660,"line_start":119,"line_end":119,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    .bind(&amount)","highlight_start":12,"highlight_end":18}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":3648,"byte_end":3652,"line_start":119,"line_end":119,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&amount)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&bigdecimal::BigDecimal` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:119:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&amount)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `&'a str` implements `Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n              `&T` implements `Encode<'q, DB>`\n              `&[T]` implements `Encode<'q, Postgres>`\n              `&[u8]` implements `Encode<'_, Postgres>`\n              `&str` implements `Encode<'_, Postgres>`\n              `Box<[u8]>` implements `Encode<'_, Postgres>`\n              `Box<str>` implements `Encode<'_, Postgres>`\n            and 42 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&bigdecimal::BigDecimal` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":3654,"byte_end":3660,"line_start":119,"line_end":119,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    .bind(&amount)","highlight_start":12,"highlight_end":18}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":3648,"byte_end":3652,"line_start":119,"line_end":119,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&amount)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&bigdecimal::BigDecimal` to implement `Type<Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":3653,"byte_end":3653,"line_start":119,"line_end":119,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(&amount)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":3660,"byte_end":3660,"line_start":119,"line_end":119,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"    .bind(&amount)","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:119:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&amount)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&bigdecimal::BigDecimal` to implement `Type<Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m119\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0m&amount\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m       \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":3160,"byte_end":3715,"line_start":107,"line_end":122,"column_start":23,"column_end":6,"is_primary":false,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO transactions (id, user_id, wallet_id, category_id, transaction_type, amount, description, date)","highlight_start":1,"highlight_end":116},{"text":"        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)","highlight_start":1,"highlight_end":48},{"text":"        RETURNING id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":123},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(tx_id)","highlight_start":1,"highlight_end":17},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(payload.wallet_id)","highlight_start":1,"highlight_end":29},{"text":"    .bind(payload.category_id)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&payload.transaction_type)","highlight_start":1,"highlight_end":37},{"text":"    .bind(&amount)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&payload.description)","highlight_start":1,"highlight_end":32},{"text":"    .bind(date)","highlight_start":1,"highlight_end":16},{"text":"    .fetch_one(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":3715,"byte_end":3724,"line_start":122,"line_end":122,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/transaction.rs","byte_start":210,"byte_end":232,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"pub struct Transaction {","highlight_start":1,"highlight_end":23}],"label":"doesn't satisfy `_: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-9184969283753293583.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:122:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m107\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________________-\u001b[0m\n\u001b[1m\u001b[94m108\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         INSERT INTO transactions (id, user_id, wallet_id, category_id, tra\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(date)\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/transaction.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-9184969283753293583.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Encode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4054,"byte_end":4068,"line_start":135,"line_end":135,"column_start":12,"column_end":26,"is_primary":true,"text":[{"text":"    .bind(&balance_change)","highlight_start":12,"highlight_end":26}],"label":"the trait `Encode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":4048,"byte_end":4052,"line_start":135,"line_end":135,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&balance_change)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&bigdecimal::BigDecimal` to implement `Encode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs","byte_start":2937,"byte_end":2951,"line_start":81,"line_end":81,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Encode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:135:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&balance_change)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `&'a str` implements `Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n              `&T` implements `Encode<'q, DB>`\n              `&[T]` implements `Encode<'q, Postgres>`\n              `&[u8]` implements `Encode<'_, Postgres>`\n              `&str` implements `Encode<'_, Postgres>`\n              `Box<[u8]>` implements `Encode<'_, Postgres>`\n              `Box<str>` implements `Encode<'_, Postgres>`\n            and 42 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&bigdecimal::BigDecimal` to implement `Encode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs:81:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4054,"byte_end":4068,"line_start":135,"line_end":135,"column_start":12,"column_end":26,"is_primary":true,"text":[{"text":"    .bind(&balance_change)","highlight_start":12,"highlight_end":26}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":4048,"byte_end":4052,"line_start":135,"line_end":135,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&balance_change)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&bigdecimal::BigDecimal` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs","byte_start":2954,"byte_end":2962,"line_start":81,"line_end":81,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4053,"byte_end":4053,"line_start":135,"line_end":135,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(&balance_change)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":4068,"byte_end":4068,"line_start":135,"line_end":135,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"    .bind(&balance_change)","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:135:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&balance_change)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&bigdecimal::BigDecimal` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query.rs:81:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0m&balance_change\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m               \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4573,"byte_end":4584,"line_start":155,"line_end":155,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:155:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4573,"byte_end":4584,"line_start":155,"line_end":155,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:155:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4553,"byte_end":4831,"line_start":155,"line_end":163,"column_start":23,"column_end":6,"is_primary":false,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":120},{"text":"        FROM transactions WHERE id = $1 AND user_id = $2","highlight_start":1,"highlight_end":57},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":4831,"byte_end":4845,"line_start":163,"line_end":163,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(&state.db)","highlight_start":6,"highlight_end":20}],"label":"method cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/transaction.rs","byte_start":210,"byte_end":232,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"pub struct Transaction {","highlight_start":1,"highlight_end":23}],"label":"doesn't satisfy `_: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-8906252197308392914.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:163:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________________-\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         SELECT id, user_id, wallet_id, category_id, transaction_type, amou\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         FROM transactions WHERE id = $1 AND user_id = $2\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m162\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(user_id)\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/transaction.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-8906252197308392914.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":4553,"byte_end":4868,"line_start":155,"line_end":164,"column_start":23,"column_end":12,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":120},{"text":"        FROM transactions WHERE id = $1 AND user_id = $2","highlight_start":1,"highlight_end":57},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(&state.db)","highlight_start":1,"highlight_end":31},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:155:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         SELECT id, user_id, wallet_id, category_id, transaction_type, amou\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         FROM transactions WHERE id = $1 AND user_id = $2\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m163\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(&state.db)\n\u001b[1m\u001b[94m164\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":5434,"byte_end":5445,"line_start":183,"line_end":183,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:183:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":5434,"byte_end":5445,"line_start":183,"line_end":183,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:183:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":6110,"byte_end":6116,"line_start":200,"line_end":200,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    .bind(&amount)","highlight_start":12,"highlight_end":18}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":6104,"byte_end":6108,"line_start":200,"line_end":200,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&amount)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:200:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&amount)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `&'a str` implements `Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n              `&T` implements `Encode<'q, DB>`\n              `&[T]` implements `Encode<'q, Postgres>`\n              `&[u8]` implements `Encode<'_, Postgres>`\n              `&str` implements `Encode<'_, Postgres>`\n              `Box<[u8]>` implements `Encode<'_, Postgres>`\n              `Box<str>` implements `Encode<'_, Postgres>`\n            and 42 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":6110,"byte_end":6116,"line_start":200,"line_end":200,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    .bind(&amount)","highlight_start":12,"highlight_end":18}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":6104,"byte_end":6108,"line_start":200,"line_end":200,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&amount)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:200:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&amount)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":5414,"byte_end":6212,"line_start":183,"line_end":205,"column_start":23,"column_end":6,"is_primary":false,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        UPDATE transactions SET","highlight_start":1,"highlight_end":32},{"text":"            wallet_id = COALESCE($1, wallet_id),","highlight_start":1,"highlight_end":49},{"text":"            category_id = COALESCE($2, category_id),","highlight_start":1,"highlight_end":53},{"text":"            transaction_type = COALESCE($3, transaction_type),","highlight_start":1,"highlight_end":63},{"text":"            amount = COALESCE($4, amount),","highlight_start":1,"highlight_end":43},{"text":"            description = COALESCE($5, description),","highlight_start":1,"highlight_end":53},{"text":"            date = COALESCE($6, date),","highlight_start":1,"highlight_end":39},{"text":"            updated_at = NOW()","highlight_start":1,"highlight_end":31},{"text":"        WHERE id = $7 AND user_id = $8","highlight_start":1,"highlight_end":39},{"text":"        RETURNING id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":123},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(payload.wallet_id)","highlight_start":1,"highlight_end":29},{"text":"    .bind(payload.category_id)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&payload.transaction_type)","highlight_start":1,"highlight_end":37},{"text":"    .bind(&amount)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&payload.description)","highlight_start":1,"highlight_end":32},{"text":"    .bind(payload.date)","highlight_start":1,"highlight_end":24},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":6212,"byte_end":6226,"line_start":205,"line_end":205,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(&state.db)","highlight_start":6,"highlight_end":20}],"label":"method cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/transaction.rs","byte_start":210,"byte_end":232,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"pub struct Transaction {","highlight_start":1,"highlight_end":23}],"label":"doesn't satisfy `_: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-12223898257957216050.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:205:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________________-\u001b[0m\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         UPDATE transactions SET\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             wallet_id = COALESCE($1, wallet_id),\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m204\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(user_id)\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/transaction.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-12223898257957216050.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":5414,"byte_end":6249,"line_start":183,"line_end":206,"column_start":23,"column_end":12,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        UPDATE transactions SET","highlight_start":1,"highlight_end":32},{"text":"            wallet_id = COALESCE($1, wallet_id),","highlight_start":1,"highlight_end":49},{"text":"            category_id = COALESCE($2, category_id),","highlight_start":1,"highlight_end":53},{"text":"            transaction_type = COALESCE($3, transaction_type),","highlight_start":1,"highlight_end":63},{"text":"            amount = COALESCE($4, amount),","highlight_start":1,"highlight_end":43},{"text":"            description = COALESCE($5, description),","highlight_start":1,"highlight_end":53},{"text":"            date = COALESCE($6, date),","highlight_start":1,"highlight_end":39},{"text":"            updated_at = NOW()","highlight_start":1,"highlight_end":31},{"text":"        WHERE id = $7 AND user_id = $8","highlight_start":1,"highlight_end":39},{"text":"        RETURNING id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at","highlight_start":1,"highlight_end":123},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(payload.wallet_id)","highlight_start":1,"highlight_end":29},{"text":"    .bind(payload.category_id)","highlight_start":1,"highlight_end":31},{"text":"    .bind(&payload.transaction_type)","highlight_start":1,"highlight_end":37},{"text":"    .bind(&amount)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&payload.description)","highlight_start":1,"highlight_end":32},{"text":"    .bind(payload.date)","highlight_start":1,"highlight_end":24},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(&state.db)","highlight_start":1,"highlight_end":31},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:183:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         UPDATE transactions SET\n\u001b[1m\u001b[94m186\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             wallet_id = COALESCE($1, wallet_id),\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(&state.db)\n\u001b[1m\u001b[94m206\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":6782,"byte_end":6793,"line_start":224,"line_end":224,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:224:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":6782,"byte_end":6793,"line_start":224,"line_end":224,"column_start":43,"column_end":54,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":43,"highlight_end":54}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":194,"byte_end":207,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":221,"byte_end":232,"line_start":8,"line_end":8,"column_start":12,"column_end":23,"is_primary":true,"text":[{"text":"pub struct Transaction {","highlight_start":12,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:224:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::transaction::Transaction` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":6762,"byte_end":7026,"line_start":224,"line_end":230,"column_start":23,"column_end":6,"is_primary":false,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"SELECT id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at ","highlight_start":1,"highlight_end":124},{"text":"           FROM transactions WHERE id = $1 AND user_id = $2\"#","highlight_start":1,"highlight_end":62},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/transaction.rs","byte_start":7026,"byte_end":7040,"line_start":230,"line_end":230,"column_start":6,"column_end":20,"is_primary":true,"text":[{"text":"    .fetch_optional(&state.db)","highlight_start":6,"highlight_end":20}],"label":"method cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/transaction.rs","byte_start":210,"byte_end":232,"line_start":8,"line_end":8,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"pub struct Transaction {","highlight_start":1,"highlight_end":23}],"label":"doesn't satisfy `_: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-8906252197308392914.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_optional` exists for struct `QueryAs<'_, Postgres, Transaction, ...>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:230:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________________-\u001b[0m\n\u001b[1m\u001b[94m225\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"SELECT id, user_id, wallet_id, category_id, transaction_type, a\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m226\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m            FROM transactions WHERE id = $1 AND user_id = $2\"#\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m229\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(user_id)\n\u001b[1m\u001b[94m230\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_optional(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Transaction, ...>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/transaction.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Transaction {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-8906252197308392914.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":6762,"byte_end":7063,"line_start":224,"line_end":231,"column_start":23,"column_end":12,"is_primary":true,"text":[{"text":"    let transaction = sqlx::query_as::<_, Transaction>(","highlight_start":23,"highlight_end":56},{"text":"        r#\"SELECT id, user_id, wallet_id, category_id, transaction_type, amount, description, date, created_at, updated_at ","highlight_start":1,"highlight_end":124},{"text":"           FROM transactions WHERE id = $1 AND user_id = $2\"#","highlight_start":1,"highlight_end":62},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_optional(&state.db)","highlight_start":1,"highlight_end":31},{"text":"    .await?","highlight_start":1,"highlight_end":12}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:224:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let transaction = sqlx::query_as::<_, Transaction>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________________^\u001b[0m\n\u001b[1m\u001b[94m225\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"SELECT id, user_id, wallet_id, category_id, transaction_type, a\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m226\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m            FROM transactions WHERE id = $1 AND user_id = $2\"#\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m230\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_optional(&state.db)\n\u001b[1m\u001b[94m231\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await?\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|___________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":1804,"byte_end":1810,"line_start":64,"line_end":64,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    let wallet = sqlx::query_as::<_, Wallet>(","highlight_start":38,"highlight_end":44}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:64:38\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let wallet = sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":1804,"byte_end":1810,"line_start":64,"line_end":64,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    let wallet = sqlx::query_as::<_, Wallet>(","highlight_start":38,"highlight_end":44}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:64:38\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let wallet = sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":2172,"byte_end":2179,"line_start":75,"line_end":75,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":12,"highlight_end":19}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":2166,"byte_end":2170,"line_start":75,"line_end":75,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&balance)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `&'a str` implements `Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n  `&T` implements `Encode<'q, DB>`\n  `&[T]` implements `Encode<'q, Postgres>`\n  `&[u8]` implements `Encode<'_, Postgres>`\n  `&str` implements `Encode<'_, Postgres>`\n  `Box<[u8]>` implements `Encode<'_, Postgres>`\n  `Box<str>` implements `Encode<'_, Postgres>`\nand 42 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&bigdecimal::BigDecimal` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Encode<'_, Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:75:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&balance)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Encode<'_, Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n             `&'a str` implements `Encode<'a, sqlx::Any>`\n             `&'q [u8]` implements `Encode<'q, sqlx::Any>`\n             `&T` implements `Encode<'q, DB>`\n             `&[T]` implements `Encode<'q, Postgres>`\n             `&[u8]` implements `Encode<'_, Postgres>`\n             `&str` implements `Encode<'_, Postgres>`\n             `Box<[u8]>` implements `Encode<'_, Postgres>`\n             `Box<str>` implements `Encode<'_, Postgres>`\n           and 42 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&bigdecimal::BigDecimal` to implement `Encode<'_, Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> S\u001b[1m\u001b[94m...\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":2172,"byte_end":2179,"line_start":75,"line_end":75,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":12,"highlight_end":19}],"label":"the trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":2166,"byte_end":2170,"line_start":75,"line_end":75,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&balance)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&bigdecimal::BigDecimal` to implement `Type<Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":2171,"byte_end":2171,"line_start":75,"line_end":75,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":2179,"byte_end":2179,"line_start":75,"line_end":75,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<Postgres>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:75:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&balance)\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n             `&T` implements `Type<DB>`\n             `()` implements `Type<Postgres>`\n             `(T1, T2)` implements `Type<Postgres>`\n             `(T1, T2, T3)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n             `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n           and 53 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&bigdecimal::BigDecimal` to implement `Type<Postgres>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n  \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m75\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0m&balance\u001b[92m,)\u001b[0m)\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m        \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":1784,"byte_end":2237,"line_start":64,"line_end":78,"column_start":18,"column_end":6,"is_primary":false,"text":[{"text":"    let wallet = sqlx::query_as::<_, Wallet>(","highlight_start":18,"highlight_end":46},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO wallets (id, user_id, name, wallet_type, balance, icon, color)","highlight_start":1,"highlight_end":83},{"text":"        VALUES ($1, $2, $3, $4, $5, $6, $7)","highlight_start":1,"highlight_end":44},{"text":"        RETURNING id, user_id, name, wallet_type, balance, icon, color, created_at, updated_at","highlight_start":1,"highlight_end":95},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(wallet_id)","highlight_start":1,"highlight_end":21},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&payload.name)","highlight_start":1,"highlight_end":25},{"text":"    .bind(&payload.wallet_type)","highlight_start":1,"highlight_end":32},{"text":"    .bind(&balance)","highlight_start":1,"highlight_end":20},{"text":"    .bind(&payload.icon)","highlight_start":1,"highlight_end":25},{"text":"    .bind(&payload.color)","highlight_start":1,"highlight_end":26},{"text":"    .fetch_one(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":2237,"byte_end":2246,"line_start":78,"line_end":78,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/wallet.rs","byte_start":199,"byte_end":216,"line_start":8,"line_end":8,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Wallet {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `Wallet: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:78:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m64\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let wallet = sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m __________________-\u001b[0m\n \u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n \u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         INSERT INTO wallets (id, user_id, name, wallet_type, balance, icon\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         VALUES ($1, $2, $3, $4, $5, $6, $7)\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&payload.color)\n \u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/wallet.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Wallet: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":3398,"byte_end":3404,"line_start":120,"line_end":120,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    let wallet = sqlx::query_as::<_, Wallet>(","highlight_start":38,"highlight_end":44}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 50 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:120:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let wallet = sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 50 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":3398,"byte_end":3404,"line_start":120,"line_end":120,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"    let wallet = sqlx::query_as::<_, Wallet>(","highlight_start":38,"highlight_end":44}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Wallet` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":183,"byte_end":196,"line_start":7,"line_end":7,"column_start":48,"column_end":61,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":48,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(sqlx::FromRow)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.7.4/src/lib.rs","byte_start":1615,"byte_end":1672,"line_start":52,"line_end":52,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":210,"byte_end":216,"line_start":8,"line_end":8,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Wallet {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12373,"byte_end":12381,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArguments<'q>>::Arguments>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":12497,"byte_end":12525,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:120:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let wallet = sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `Wallet` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:48\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as HasArg\u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `sqlx::FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Option<BigDecimal>: Encode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":3913,"byte_end":3920,"line_start":135,"line_end":135,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":12,"highlight_end":19}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":3907,"byte_end":3911,"line_start":135,"line_end":135,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&balance)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Encode<'_, _>` is not implemented for `std::option::Option<bigdecimal::BigDecimal>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Encode<'q, DB>`:\n  `std::option::Option<T>` implements `Encode<'_, Postgres>`\n  `std::option::Option<T>` implements `Encode<'_, sqlx::Any>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1566,"byte_end":1580,"line_start":54,"line_end":54,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-13883467889090589829.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Option<BigDecimal>: Encode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:135:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&balance)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the trait `Encode<'_, _>` is not implemented for `std::option::Option<bigdecimal::BigDecimal>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\n              `std::option::Option<T>` implements `Encode<'_, Postgres>`\n              `std::option::Option<T>` implements `Encode<'_, sqlx::Any>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Encode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0mfn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> \u001b[1m\u001b[94m...\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-13883467889090589829.txt'\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":3913,"byte_end":3920,"line_start":135,"line_end":135,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":12,"highlight_end":19}],"label":"the trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":3907,"byte_end":3911,"line_start":135,"line_end":135,"column_start":6,"column_end":10,"is_primary":false,"text":[{"text":"    .bind(&balance)","highlight_start":6,"highlight_end":10}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 53 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<bigdecimal::BigDecimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"1 redundant requirement hidden","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs","byte_start":1583,"byte_end":1591,"line_start":54,"line_end":54,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":3912,"byte_end":3912,"line_start":135,"line_end":135,"column_start":11,"column_end":11,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":11,"highlight_end":11}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":3920,"byte_end":3920,"line_start":135,"line_end":135,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    .bind(&balance)","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:135:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(&balance)\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m----\u001b[0m  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 53 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<bigdecimal::BigDecimal>` to implement `Type<_>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: 1 redundant requirement hidden\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&std::option::Option<bigdecimal::BigDecimal>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.7.4/src/query_as.rs:54:49\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `QueryAs::<'q, DB, O, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m135\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .bind(\u001b[92m(\u001b[0m&balance\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[92m+\u001b[0m        \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":3378,"byte_end":4011,"line_start":120,"line_end":140,"column_start":18,"column_end":6,"is_primary":false,"text":[{"text":"    let wallet = sqlx::query_as::<_, Wallet>(","highlight_start":18,"highlight_end":46},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        UPDATE wallets SET","highlight_start":1,"highlight_end":27},{"text":"            name = COALESCE($1, name),","highlight_start":1,"highlight_end":39},{"text":"            wallet_type = COALESCE($2, wallet_type),","highlight_start":1,"highlight_end":53},{"text":"            balance = COALESCE($3, balance),","highlight_start":1,"highlight_end":45},{"text":"            icon = COALESCE($4, icon),","highlight_start":1,"highlight_end":39},{"text":"            color = COALESCE($5, color),","highlight_start":1,"highlight_end":41},{"text":"            updated_at = NOW()","highlight_start":1,"highlight_end":31},{"text":"        WHERE id = $6 AND user_id = $7","highlight_start":1,"highlight_end":39},{"text":"        RETURNING id, user_id, name, wallet_type, balance, icon, color, created_at, updated_at","highlight_start":1,"highlight_end":95},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(&payload.name)","highlight_start":1,"highlight_end":25},{"text":"    .bind(&payload.wallet_type)","highlight_start":1,"highlight_end":32},{"text":"    .bind(&balance)","highlight_start":1,"highlight_end":20},{"text":"    .bind(&payload.icon)","highlight_start":1,"highlight_end":25},{"text":"    .bind(&payload.color)","highlight_start":1,"highlight_end":26},{"text":"    .bind(id)","highlight_start":1,"highlight_end":14},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_one(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/wallet.rs","byte_start":4011,"byte_end":4020,"line_start":140,"line_end":140,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/wallet.rs","byte_start":199,"byte_end":216,"line_start":8,"line_end":8,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Wallet {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `Wallet: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs","byte_start":5627,"byte_end":5648,"line_start":211,"line_end":211,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub struct BigDecimal {","highlight_start":1,"highlight_end":22}],"label":"doesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`bigdecimal::BigDecimal: Type<Postgres>`\n`bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, Wallet, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:140:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m120\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let wallet = sqlx::query_as::<_, Wallet>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m __________________-\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         UPDATE wallets SET\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             name = COALESCE($1, name),\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m139\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(user_id)\n\u001b[1m\u001b[94m140\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, Wallet, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/wallet.rs:8:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Wallet {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Wallet: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bigdecimal-0.4.9/src/lib.rs:211:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct BigDecimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m---------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `bigdecimal::BigDecimal: Type<Postgres>` or `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `bigdecimal::BigDecimal: Type<Postgres>`\n            `bigdecimal::BigDecimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/wallet.rs","byte_start":159,"byte_end":168,"line_start":7,"line_end":7,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":24,"highlight_end":33}],"label":"the trait `Serialize` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":159,"byte_end":168,"line_start":7,"line_end":7,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/wallet.rs","byte_start":352,"byte_end":355,"line_start":13,"line_end":13,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    pub balance: BigDecimal,","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 185 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `dashboard::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-12625583750531698474.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Serialize` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:24\n     \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Serialize` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n  \u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub balance: BigDecimal,\n     \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `bigdecimal::BigDecimal` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Serialize`:\n               &'a T\n               &'a mut T\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n               (T0, T1, T2, T3, T4)\n             and 185 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `dashboard::_::_serde::ser::SerializeStruct::serialize_field`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs:1917:21\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Resul\u001b[1m\u001b[94m...\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1916\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1917\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: ?Sized + Serialize;\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-12625583750531698474.txt'\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/wallet.rs","byte_start":365,"byte_end":375,"line_start":13,"line_end":13,"column_start":18,"column_end":28,"is_primary":true,"text":[{"text":"    pub balance: BigDecimal,","highlight_start":18,"highlight_end":28}],"label":"the trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a JsonRawValue\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\nand 199 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:13:18\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub balance: BigDecimal,\n     \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a JsonRawValue\n               &'a [u8]\n               &'a std::path::Path\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n             and 199 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_element`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1771:12\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1769\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1770\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1771\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: Deserialize<'de>,\n     \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/wallet.rs","byte_start":365,"byte_end":375,"line_start":13,"line_end":13,"column_start":18,"column_end":28,"is_primary":true,"text":[{"text":"    pub balance: BigDecimal,","highlight_start":18,"highlight_end":28}],"label":"the trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a JsonRawValue\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\nand 199 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:13:18\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub balance: BigDecimal,\n     \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a JsonRawValue\n               &'a [u8]\n               &'a std::path::Path\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n             and 199 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_value`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1916:12\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1914\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1916\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         V: Deserialize<'de>,\n     \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `MapAccess::next_value`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/wallet.rs","byte_start":170,"byte_end":181,"line_start":7,"line_end":7,"column_start":35,"column_end":46,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":35,"highlight_end":46}],"label":"the trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/wallet.rs","byte_start":170,"byte_end":181,"line_start":7,"line_end":7,"column_start":35,"column_end":46,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":35,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a JsonRawValue\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\nand 199 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `dashboard::_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/models/wallet.rs:7:35\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n             &'a JsonRawValue\n             &'a [u8]\n             &'a std::path::Path\n             &'a str\n             ()\n             (T,)\n             (T0, T1)\n             (T0, T1, T2)\n           and 199 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `dashboard::_::_serde::__private228::de::missing_field`\n  \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs:26:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     V: Deserialize<'de>,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `missing_field`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/transaction.rs","byte_start":170,"byte_end":179,"line_start":7,"line_end":7,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":24,"highlight_end":33}],"label":"the trait `Serialize` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":170,"byte_end":179,"line_start":7,"line_end":7,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/transaction.rs","byte_start":403,"byte_end":406,"line_start":14,"line_end":14,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    pub amount: BigDecimal,","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 185 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `dashboard::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-12625583750531698474.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Serialize` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:24\n     \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Serialize` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n  \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub amount: BigDecimal,\n     \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `bigdecimal::BigDecimal` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Serialize`:\n               &'a T\n               &'a mut T\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n               (T0, T1, T2, T3, T4)\n             and 185 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `dashboard::_::_serde::ser::SerializeStruct::serialize_field`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs:1917:21\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Resul\u001b[1m\u001b[94m...\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1916\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1917\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: ?Sized + Serialize;\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-12625583750531698474.txt'\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/transaction.rs","byte_start":415,"byte_end":425,"line_start":14,"line_end":14,"column_start":17,"column_end":27,"is_primary":true,"text":[{"text":"    pub amount: BigDecimal,","highlight_start":17,"highlight_end":27}],"label":"the trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a JsonRawValue\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\nand 200 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:14:17\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub amount: BigDecimal,\n     \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a JsonRawValue\n               &'a [u8]\n               &'a std::path::Path\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n             and 200 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_element`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1771:12\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1769\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1770\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1771\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: Deserialize<'de>,\n     \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/transaction.rs","byte_start":415,"byte_end":425,"line_start":14,"line_end":14,"column_start":17,"column_end":27,"is_primary":true,"text":[{"text":"    pub amount: BigDecimal,","highlight_start":17,"highlight_end":27}],"label":"the trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a JsonRawValue\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\nand 200 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:14:17\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub amount: BigDecimal,\n     \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a JsonRawValue\n               &'a [u8]\n               &'a std::path::Path\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n             and 200 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_value`\n    \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1916:12\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1914\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1916\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         V: Deserialize<'de>,\n     \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `MapAccess::next_value`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/transaction.rs","byte_start":181,"byte_end":192,"line_start":7,"line_end":7,"column_start":35,"column_end":46,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":35,"highlight_end":46}],"label":"the trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/transaction.rs","byte_start":181,"byte_end":192,"line_start":7,"line_end":7,"column_start":35,"column_end":46,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]","highlight_start":35,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a JsonRawValue\n  &'a [u8]\n  &'a std::path::Path\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\nand 200 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `dashboard::_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using `--verbose` to print the full type name to the console","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `bigdecimal::BigDecimal: serde::Deserialize<'de>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/models/transaction.rs:7:35\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Deserialize<'_>` is not implemented for `bigdecimal::BigDecimal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `bigdecimal::BigDecimal` type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n             &'a JsonRawValue\n             &'a [u8]\n             &'a std::path::Path\n             &'a str\n             ()\n             (T,)\n             (T0, T1)\n             (T0, T1, T2)\n           and 200 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `dashboard::_::_serde::__private228::de::missing_field`\n  \u001b[1m\u001b[94m--> \u001b[0m/home/beatfraps/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs:26:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     V: Deserialize<'de>,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `missing_field`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the full name for the type has been written to '/home/beatfraps/Documents/fintrack/Cursor/backend/target/debug/deps/fintrack_api-f89738faf3386ad3.long-type-5233987882577023916.txt'\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: consider using `--verbose` to print the full type name to the console\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"unused import: `sqlx::Row`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/auth.rs","byte_start":126,"byte_end":135,"line_start":7,"line_end":7,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use sqlx::Row;","highlight_start":5,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `sqlx::Row`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/auth.rs:7:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use sqlx::Row;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `sqlx::Row`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/dashboard.rs","byte_start":205,"byte_end":214,"line_start":10,"line_end":10,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use sqlx::Row;","highlight_start":5,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `sqlx::Row`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/dashboard.rs:10:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use sqlx::Row;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `sqlx::Row`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/transaction.rs","byte_start":186,"byte_end":195,"line_start":9,"line_end":9,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use sqlx::Row;","highlight_start":5,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `sqlx::Row`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/transaction.rs:9:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use sqlx::Row;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `sqlx::Row`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/wallet.rs","byte_start":162,"byte_end":171,"line_start":8,"line_end":8,"column_start":5,"column_end":14,"is_primary":true,"text":[{"text":"use sqlx::Row;","highlight_start":5,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `sqlx::Row`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/wallet.rs:8:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use sqlx::Row;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 74 previous errors; 11 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 74 previous errors; 11 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
